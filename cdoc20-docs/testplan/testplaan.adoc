:source-highlighter: rouge
:table-caption: Tabel
:figure-caption: Joonis
:imagesdir: images
:pdf-style: cyber-theme.yml
:icons: font
:classification: AVALIK
:title-page-background-image: {pdf-stylesdir}/images/title_page_bg_Avalik.svg
:title-page:
:toclevels: 3
:toc-title: Sisukord
:version-label: Versioon
:numbered:
:docnumber:
:author: Tehniline dokument
:revdate: 30.05.2022
:revnumber: 1.0
:numbered:
:docnumber: D-X-XXX
:author: D-X-XXX

= CDOC 2.0 võtmeedastusserveri testiplaan

== Sissejuhatus

=== Dokumendi eesmärk

Käesoleva testiplaani eesmärk on anda ülevaade CDOC2.0 võtmeedastusserveri testimise tegevustest, rakendatavatest testidest ja testimise käigus tekkivatest tulemitest.

Tulenevalt testitava võtmeedastusserveri funktsionaalsuse piiratusest on testiplaanis kirjas ka planeeritavad testistsenaariumid.

=== Kasutatud dokumentatsioon

Testiplaani koostamise aluseks on CDOC 2.0 projekti dokumentatsioon, mille põhjal tuvastati testimisvajadus ning planeeriti testid

* CDOC 2.0 kasutusmallimudel
* CDOC 2.0 spetsifikatsioon

== Testimise eesmärk ja ulatus

Käesolev testiplaan kirjeldab CDOC 2.0 võtmeedastusserveri (Server) testimisega seotud tegevusi. Käesolev testiplaan ei kata CDOC 2.0 kliendipoolseid komponente ning keskendub vaid serverile.

Käesoleva testiplaani raames on Serveri testimisel kaks peamist eesmärki:

*	funktsionaalse testimisega selgitada välja kas Serveri realiseeritud funktsionaalsus vastab dokumentatsioonis kirjeldatule ning kas Server suudab täita seatud eesmärke
*	koormustestidega teha kindlaks serveri toimimine ja käitumine erinevate kasutusmahtude ja -mustrite korral.

=== Funktsionaalne testimine

Funktsionaalse testimise eesmärk on teha kindlaks, kas Serveri realiseeritud funktsionaalsus vastab dokumentatsioonis kirjeldatule ning kas Server suudab täita seatud eesmärgid.

Funktsionaalse testimise puhul kasutatakse arendajate poolt kirjutatavaid ühikteste ning automatiseeritud API teste, mis katavad ära serveri kasutusmallides kirjeldatud stsenaariumid ning võimalikud API veasituatsioonid.

=== Koormustestimine

Serveri võimekusele otseselt nõudmisi esitatud ei ole, kuid sellegipoolest on oluline teada loodud tarkvara võimete piire mingil kindlal olemasoleval platvormil.
Selle info hankimiseks kasutatakse koormusteste, millega otsitakse vastuseid alljärgnevatele küsimustele:

*	Milline on süsteemi vasteaeg kasutajale erinevate süsteemi koormuste juures?
*	Kui palju kasutajaid korraga suudab süsteem teenindada kokkulepitud vasteaega ületamata?
*	Kuidas käitub süsteem piirsituatsioonides (väga palju kasutajaid korraga, väga palju võtmeosakuid baasis) ?
*	Kuidas taastub süsteem tippkoormuse taandumisel?
*	Kuidas käitub süsteem pikemaajalise mõõduka või suurema koormuse korral?

== Testimise korraldus ja tulemid

Testimise planeerimine on jätkuv tegevus, mida korratakse projekti jooksul korduvalt uue täiendava olulise info lisandumisel. Testimise planeerimise tulemiks on testiplaan (käesolev dokument).

Funktsionaalne testimine on võtmeedastusserveri puhul kaetud ühiktestidega ning Serveri API vastu rakendatud API testidega.

Ühiktestid on loodud arendajate poolt ning kasutatavad nii arendajate poolt kui ka pidevkooste (_continuous integration_) keskkonnas. Testide käivitamise tulemuseks on nii inim- kui masinloetav testiraport. Ühiktestide koodi hallatakse koos Serveri koodiga ning neile rakendatakse samu põhimõtteid, mis rakenduse koodilegi.

Võtmeedastusserveri API testid on planeeritud realiseerida sarnaselt ühiktestidele samuti automaattestidena, et nende käivitamine oleks võimalikult lihtne ja vähese vaevaga korratav. Funktsionaalsete testide käivitamise kohta genereeritakse kasutatava vahendi poolt testiraport.

API testide loomiseks valitakse vahendid selliselt, et loodavad testid oleksid võimalikult lihtsasti hallatavad ning nende kood oleks hallatav koos rakenduse koodiga ning samade põhimõtete kohaselt.

Serveri suutlikkuse tuvastamiseks kasutatavad testid realiseeritakse samuti automaatsete testidena sobilikumat testimisvahendit kasutades. Sobivaim vahend selgitatakse välja testide arenduse käigus, arvestades järgnevaid asjaolusid:

* testide loomine ei tohi olla arendajale ebamõistlikult keerukas
* soovitud koormuste tekitamise seadistamine ei tohi nõuda arendaja oskusi
* pakutav testiraport peab olema hõlpsasti saadav ning mõistetav

Koormustestide puhul peab arvestama, et testide loomise skoobis on süsteemi koormamise võimekus ning koormustestid ei kata süsteemi monitoorimise lahendust koormustestide ajal. Süsteemi monitoorimiseks kasutada selleks mõeldud vahendeid.

Koormustestide tulemuseks on testiraport, mis sisaldab informatsiooni koormustestide peatükis kirjeldatud küsimustele vastamiseks. Raport sisaldab nii Serverile rakendatavate koormuste infot kui päringute teenindamiseks vajaminevate süsteemsete ressursside kasutust (mälumaht, protsessori koormus, salvestusruumi kasutus)

== Planeeritud testimise stsenaariumid

Tavapäraselt ei ole testiideed ning stsenaariumid otseselt testiplaani osa. Võtmeedastusserveri puhul on aga tegemist piiratud funktsionaalsusega rakendusega, mille puhul ei ole otstarbekas testistsenaariumite haldamiseks luua eraldi dokumenti. Samuti on selles peatükis kirjeldatud ka koormustestide puhul kasutada planeeritavad stsenaariumid.

=== Võtmeedastusserveri API funktsionaalsed testid

Serveri funktsionaalsust testitakse läbi Serveri API liideste lõppkasutaja kliendirakendust emuleerides.
Testid käivitatakse nii ECC kui RSA võtmetele.
Positiivsed stsenaariumid:

*	Saatjal õnnestub võtmekapsli edastamine Serverile ([ECC|RSA]-PUT_CAPSULE-POS-01-ONCE)
*	Saatja on juba võtmekapsli edastanud ja saadab uuesti Serverile ([ECC|RSA]-PUT_CAPSULE-POS-02-REPEATEDLY)
*	Saatja edastab serverile RSA võtmematerjalina suvalise baidijada, mis ei ületa ettenähtud mahupiirangut (RSA-PUT-CAPSULE-POS-03-RANDOM_CONTENT)
*	Vastuvõtjal õnnestub võtmekapsli pärimine ([ECC|RSA]-GET_CAPSULE-POS-01-CORRECT_REQUEST)
*	Edukas võtmekapsli edastamine mitme-õlgse süsteemi puhul -- kapsli võtab vastu üks süsteemi õlg ning väljastab teine õlg

Negatiivsed stsenaariumid

*	Saatja saadab liiga suure võtmematerjaliga RSA võtmekapsli (RSA-PUT_CAPSULE-NEG-01-CAPSULE_TOO_BIG)
*	Vastuvõtja pärib võtmekapslit juhusliku transaktsiooni identifikaatoriga (GET_CAPSULE-NEG-02-RANDOM_UUID_TRANSACTION_ID)
*	Vastuvõtja pärib võtmekapslit liiga lühikese transaktsiooni identifikaatoriga(GET_CAPSULE-NEG-03-TOO_SHORT_TRANSACTION_ID)
*	Vastuvõtja pärib võtmekapslit tühja transaktsiooni identifikaatoriga(GET_CAPSULE-NEG-04-EMPTY_STRING_TRANSACTION_ID)
*	Vastuvõtja pärib võtmekapslit liiga pika transaktsiooni identifikaatoriga(GET_CAPSULE-NEG-05-TOO_LONG_RANDOM_STRING_TRANSACTION_ID)
*	Vastuvõtja pärib võtmekapslit korrektse transaktsiooni identifikaatoriga, aga vastuvõtja avalik võti ei klapi sellega ([ECC|RSA]-GET_CAPSULE-NEG-06-PUBLIC_KEY_NOT_MATCHING)

=== Serveri koormustestid

Koormuse all serveri käitumise kohta info hankimiseks on vaja serverit koormata päringutega, mis võimalikult täpselt püüavad jäljendada võimalikku reaalelulist kasutajate käitumismustrit.

Lähtuvalt võtmeedastusserveri ülesehitusest ja funktsionaalsusest jagunevad serverile tehtavad päringud kahte suuremasse rühma - võtmekapslite laadimine serverisse ning võtmekapslite pärimine läbi kasutaja autentimise. Kuna serveri puhul kasutatakse kahe erineva tasemega autentimist, siis sisuliselt on tegemist ka kahe iseseisva erinevalt konfigureeritud veebiserveriga, mille ühisosaks on ühtne andmebaas võtmeosakute hoidmiseks.

Võtmeserveri koormuse tekitamiseks on vaja kasutada päringuid võtmeosakute serverisse laadimiseks ning võtmeosakute serverist küsimiseks.

* Võtmekapslite serverisse laadimise päringute puhul kasutatakse funktsionaalselt edukaid päringuid, mille puhul võtmekapslid salvestatakse serveri andmebaasi.
* Võtmekapslite serverist küsimisel valitakse päringus kasutatav võtmekapsel ning autenditud kasutaja juhuslikkuse alusel ning serveri poolt tagastatav vastus võib olla nii positiivne (sisaldab võtmekapslit) kui ka negatiivne (tagastatakse veakood).

Päringu vastuse sisu ei oma koormustestimise puhul tähtsust, kuna nii positiivse kui negatiivse tulemuseni jõudmiseks on vaja teha samad sisemised päringud ja võrdlused.


==== Koormuse tekitamine

Koormustestimisel on sarnaselt funktsionaalsetele testidele kasutusel Gatling testiraamistik, mille puhul on võimalik soovitud koormus testitavale tarkvarale saavutada järgmiseid parameetreid kasutades:

- start-users-per-second - testide käivitamisel koheselt rakenduv aktiivsete kasutajate arv (päringut sekundis)
- increment-users-per-second - igal järgneval testitsüklil lisanduv aktiivsete kasutajate arv
- increment-cycles - läbitavate testitsüklite arv
- cycle-duration-seconds - testitsükli kestus (sekundites)

Koormustesti kestus sõltub testitsüklite arvust ning tsükli pikkusest.
Testitavale tarkvarale tehtav päringute hulk sõltub esialgsest kasutajate arvust ning iga järgneva testitsükliga lisanduvate kasutajate hulgast.
Näiteks ühtlaselt kasvava koormuse tekitamiseks võib esialgselt rakendatava kasutajate arvu seada mõõdukalt väikeseks ning kasutada suuremat hulka lisanduvaid kasutajaid testitsükli jooksul.

Alljärgneva seadistuse puhul kestab test 600 sekundit (10 minutit) ning testi alguses on päringute hulk 10 päringut sekundis ning testi viimases tsüklis 110 päringut sekundis:

- start-users-per-second = 10
- increment-users-per-second = 10
- increment-cycles = 10
- cycle-duration-seconds = 60

Ühtlase koormuse saavutamiseks tuleks seadistada koheselt rakendatav kasutajate hulk soovitud koormusele ning jätta igas testitsüklis lisanduvate kasutajate hulk minimaalseks

Alljärgneva seadistuse puhul kestab test 600 sekundit (10 minutit) ning kohe testi alguses on päringute hulk 75 päringut sekundis ning testi viimases tsüklis 85 päringut sekundis:

- start-users-per-second = 10
- increment-users-per-second = 1
- increment-cycles = 10
- cycle-duration-seconds = 60



==== Stsenaariumite rakendamine koormustestides

* Milline on süsteemi vasteaeg kasutajale erinevate süsteemi koormuste juures?
* Kui palju kasutajaid korraga suudab süsteem teenindada kokkulepitud vasteaga ületamata?

Kuna süsteemi käideldavus sõltub otseselt keskkonnast, milles süsteemi jooksutatakse, siis nendele küsimustele vastuste leidmiseks tuleb koormusteste käivitada korduvalt erinevate koormuste juures. Esmalt võib kasutada järjest kasvavat koormust võimalike piiride tuvastamiseks.

* Kuidas käitub süsteem piirsituatsioonides -- väga palju kasutajaid korraga, väga palju võtmeosakuid baasis?

Sellise testi puhul püütakse süsteem viia piirsituatsiooni või üle selle ning jälgitakse süsteemi käitumist sellistes oludes. Piirsituatsioonide kompamisel võiks kasutada püsivamat ühtlast koormust pikema aja vältel.

* Milline on süsteemi taastumise võime peale piirkoormuse taandumist?

Selle testi puhul kogutakse infot tipukoormusest taastumise võime kohta. Siinkohal võib kasutada mitut samaaegset koormustekitajat, millest üks on ühtlase koormusega pikemaajalisem test ning teine lühiajaline kasvava koormusega test.

* Kuidas käitub süsteem pikemaajalise mõõduka või suurema koormuse korral?

Süsteemi käitatakse pikema aja jooksul ühtlase mõõduka koormusega ning püütakse leida anomaaliaid või vigu, mis võivad ilmneda süsteemi pikemaajalisel tööl (väikesed mälulekked jne). Küsimusele vastuse leidmiseks võib kasutada ühtlase koormusega suurema arvu pikemat aega kestvate testitsüklitega testi.

== Testkeskkond

Võtmeedastusserver on Linux platvormil töötama planeeritud serverrakendus. Serveri testimisel kasutatakse uusimat Java LTS versiooni, mis testiplaani kirjutamise hetkel on Java versioon 17.

Detailne kasutatud testkeskkonda puudutav info kajastatakse koostatavas testiraportis.
